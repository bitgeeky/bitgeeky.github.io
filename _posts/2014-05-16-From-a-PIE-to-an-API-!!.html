---           
layout: post
title: From a PIE to an API !! 
date: 2014-05-16 09:03:05 UTC
updated: 2014-05-16 09:03:05 UTC
comments: true
categories: django factoryboy GSoC Mozilla mozwebqa pytest python testing Web QA
---

<div dir="ltr" style="text-align: left;" trbidi="on">Last week we were pretty much concerned about what to use and what not ?<br />and what changes we shall introduce in our model of Testing ?<br /><br />So may be if you have curiosity about what we used and what we decided, This post is for you !<br /><br />Overall Scenario last week: We wanted to use FactoryBoy for database object modelling and reliable data for tests.<br />So using FactoryBoy meant that we had to keep our Functional Tests with the application itself.<br />This was the change we decided to have and pretty much kicked of the work and <a href="https://github.com/mozilla/oneanddone/pull/111" target="_blank">initialized the test objects in application repository</a>.<br /><br />So what next ?<br />In our old testing model we ran the Functional tests on staging/production application already running. So now the challenge was:<br />How will we trigger the server ?<br /><br />One of the solution which instantly came to mind was using <a href="https://docs.djangoproject.com/en/1.4/topics/testing/#django.test.LiveServerTestCase" target="_blank">LiveServerTestCase&nbsp;</a><br />So things were *almost* finalized !!<br /><br />But things come to mind as we start working, and this time it was not something which could be ignored.<br />Man, we would not be able to run the tests on Staging and Production or in general any other remotely hosted clone of OneAndDone, Also running the tests locally would mean setting up of a local instance of OneAndDone. This was what came to mind as soon as I began writing the first test and it was for sure not what we wanted, because&nbsp; of mainly two reasons:<br /><br /><ol style="text-align: left;"><li>Why will a contributor developing a test case want to set up the application locally ? We definitely don't want to assume our contributors to be Application developers. So this was a hindrance for contributors.</li><li>We wanted to run the tests on staging and production because it gives us a better idea of current state of Application.</li></ol><br />So we decided to give it a rethought.<br /><br />After many discussions with other team members it settled down to two options:<br /><ol style="text-align: left;"><li>Keep the tests local for better data population and faster test runs.</li><li>Have the tests in a separate repository making it easy for contributors to work on and to make us able to run the tests on stage/prod.</li></ol><br />Finally we decided to go with the second one because of the above mentioned limitations of first, or the benefits of second overpowered the benefits of first. We realized our current model to be more advance than most of the other methods discovered.<br /><br />The main changes we decided to have in these tests that make them better and advance than the tests for most of the other Web QA projects are:<br /><br /><ul style="text-align: left;"><li>Develop and Use a REST API which interacts with database objects remotely. So it helps us to create/delete the test data. For developing this API we decided to use <a href="http://www.django-rest-framework.org/" target="_blank">Django REST framework</a> over <a href="http://tastypieapi.org/" target="_blank">tastypie</a> for some reasons based on prior experiences of developers.</li><li>We decided to use <a href="http://pytest.org/latest/fixture.html" target="_blank">pytest fixtures</a> instead of SetUp and TearDown methods which will allow creation/deletion of mock objects using the REST API.</li></ul><br />We again kicked off the work by initializing the <a href="https://github.com/mozilla/oneanddone-tests/pull/1" target="_blank">Page Objects and Base Class</a> and opened some Test Case bugs.<br />Now I am looking forward to developing the REST API and start writing the tests next week.</div>
